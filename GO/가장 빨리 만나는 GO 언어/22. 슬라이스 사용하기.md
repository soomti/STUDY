# 22. 슬라이스 사용하기

슬라이스는 배열과 같지만, 길이가 고정되어 있지 않으며 동적으로 크기가 늘어난다

##### var a []자료형

배열 값에 값을 넣지 않는다. 

```go
var a []int = make([int,5])
```

##### make

slice 함수를 사용하고 싶은 경우 make 함수를 통해 공간을 할당해야 값을 넣을 수 있다. 

```go
var a []int = make([]int,5) // make 함수로 int 형에 길이가 5인 슬라이스에 공간 할당
var b = make([]int,5) // 슬라이스를 선언할 때 자료형과 [] 생략
c := make([]int,5) // 슬라이스를 선언할 때 var 키워드, 자료형과 [] 생략 
```

슬라이스는 배열을 내장하는데, 이 배열이 더 늘어났을 경우 사용할 공간을 미리 할당할 수 있다.

##### make([]자료형, 길이, 용량)

```go
var s = make([]int, 5, 10)
```

길이 - 인덱스로 접근할 수 있는 용량. 용량이 길어도 여기까지만 접근이 가능하다

용량 - 실제로 메모리에 할당된 공간. 용량이 가득 차면, 용량은 자동으로 늘어난다. 

용량을 할당하면 새로 할당하지 않아도 성능상 이점이 있다. 

하지만, 처음부터 메모리가 많이 차지하는 단점이 있다.

##### len

슬라이스의 길이를 알 수 있다.

##### cap

슬라이스의 용량을 구할 수 있다



## 22.1 슬라이스에 값 추가하기

##### append(슬라이스,값1,값2,값3)

```go
a := []int{1,2,3}

a = append(a,4,5,6)

fmt.Println(a) // [1,2,3,4,5,6]
```

슬라이스에 다른 슬라이스를 붙히고 싶은 경우 `...`를 추가한다

```go
append(a, b...)
```



## 22.2 레퍼런스 타입

슬라이스는 레퍼런스 타입이다. 내장된 배열에 대한 포인터이므로, 슬라이스 끼리 대입하면 복사되지 않고 참조 된다.

```go
a := [3]int{1,2,3}
var b [3]int

b = a
b[0] = 9
```

배열 a를 배열 b에 대입하여 배열의 요소가 모두 복사되었다. 그래서 b[0]의 값을 대입한 뒤 출력해보면 배열 b의 첫번째 요소만 바뀐다.