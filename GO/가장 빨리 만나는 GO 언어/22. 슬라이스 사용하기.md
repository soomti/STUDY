# 22. 슬라이스 사용하기

슬라이스는 배열과 같지만, 길이가 고정되어 있지 않으며 동적으로 크기가 늘어난다

##### var a []자료형

배열 값에 값을 넣지 않는다. 

```go
var a []int = make([int,5])
```

##### make

slice 함수를 사용하고 싶은 경우 make 함수를 통해 공간을 할당해야 값을 넣을 수 있다. 

```go
var a []int = make([]int,5) // make 함수로 int 형에 길이가 5인 슬라이스에 공간 할당
var b = make([]int,5) // 슬라이스를 선언할 때 자료형과 [] 생략
c := make([]int,5) // 슬라이스를 선언할 때 var 키워드, 자료형과 [] 생략 
```

슬라이스는 배열을 내장하는데, 이 배열이 더 늘어났을 경우 사용할 공간을 미리 할당할 수 있다.

##### make([]자료형, 길이, 용량)

```go
var s = make([]int, 5, 10)
```

길이 - 인덱스로 접근할 수 있는 용량. 용량이 길어도 여기까지만 접근이 가능하다

용량 - 실제로 메모리에 할당된 공간. 용량이 가득 차면, 용량은 자동으로 늘어난다. 

용량을 할당하면 새로 할당하지 않아도 성능상 이점이 있다. 

하지만, 처음부터 메모리가 많이 차지하는 단점이 있다.

##### len

슬라이스의 길이를 알 수 있다.

##### cap

슬라이스의 용량을 구할 수 있다



## 22.1 슬라이스에 값 추가하기

##### append(슬라이스,값1,값2,값3)

```go
a := []int{1,2,3}

a = append(a,4,5,6)

fmt.Println(a) // [1,2,3,4,5,6]
```

슬라이스에 다른 슬라이스를 붙히고 싶은 경우 `...`를 추가한다

```go
append(a, b...)
```



## 22.2 레퍼런스 타입

슬라이스는 레퍼런스 타입이다. 내장된 배열에 대한 포인터이므로, 슬라이스 끼리 대입하면 복사되지 않고 참조 된다.

```go
a := [3]int{1,2,3}
var b [3]int

b = a
b[0] = 9
```

배열 a를 배열 b에 대입하여 배열의 요소가 모두 복사되었다. 그래서 b[0]의 값을 대입한 뒤 출력해보면 배열 b의 첫번째 요소만 바뀐다.



## 22.3 슬라이스 복사하기

슬라이스 요소를 모두 복사할 때는 copy 함수를 사용한다 

##### copy (복사 슬라이스, 원본 슬라이스 )

```go
a := []int {1,2,3,4,5}
b := make([]int, 3) //make 함수로 공간을 할당 

copy(b, a)

fmt.Println(a) // [1,2,3,4,5]
fmt.Pringln(b) // [1,2,3]: 3개의 요소만 복사됨 
```

복사된 슬라이스이므로, 원본 슬라이스는 바ㅜ끼지 않는다



## 22.4 슬라이스와 용량 

슬라이스는 길이를 동적으로 늘릴 수 있다.

```go
a := []int {1,2,3,4,5}

fmt.Println(len(a), cap(a))

a = append(a,6,7)

fmt.Println(len(a), cap(a))  // 10만큼 늘어나게 된다 정해진 알고리즘 만큼 용량을 늘린다.
```



## 22.5 부분 슬라이스 만들기

일정 위치를 지정하여 부분 슬라이스를 만들 수 있다. 

##### 슬라이스[시작:끝]

```go
a := []int{1,2,3,4,5}
b := a[0:5]

fmt.Println(a) // [1,2,3,4,5]
fmt.Println(b) // [1,2,3,4,5]

fmt.Println(a[0:3]) // [1,2,3]
fmt.Println(a[1:3]) // [2,3]

```

시작 인덱스 생략시 default 0

끝 인덱스 생략시 슬라이스 길이가 들어간다.

```go
a[3:] // [4,5]
a[:3] // [1,2,3]
```

##### 슬라이스[시작:끝:용량]

부분 슬라이스 생성 시, 용량도 함께 지정할 수 있다

```go
a := []int{1,2,3,4,5,6,7,8}

b := a[0:6:8]

fmt.Println(len(b),cap(b)) // 6 8
fmt.Println(b) // 1 2 3 4 5 6 
```

